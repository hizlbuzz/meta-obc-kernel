// SPDX-License-Identifier: GPL-2.0 OR BSD-3-Clause
/*
 * Copyright (C) 2021 Martin Schweingruber <martin.schweingruber@schmid-elektronik.ch>
 */

#include "stm32mp157c-qsmp-1570.dts"
#include "stm32mp15-karo-qsbase1.dtsi"
#include "stm32mp15-qsmp-lcd-panel.dtsi"

/ {
	model = "QSMP-1570 module on OBC";
    
	leds {
        compatible = "pwm-leds", "gpio-leds";
        
        can11 {
            label = "can11";
            linux,default-trigger = "none";
            gpios = <&gpioa 10 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>; /* Pin 77 */
        };

        can2 {
            label = "can2";
            linux,default-trigger = "none";
            gpios = <&gpiod 8 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>; /* Pin 76 */
        };

        relay {
            label = "relay";
            linux,default-trigger = "none";
            gpios = <&gpioi 6 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>; /* Pin 75 */
        };

        button {
            label = "button";
            linux,default-trigger = "none";
            gpios = <&gpioi 5 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>; /* Pin 74 */
        };

        on24 {
            label = "on24";
            linux,default-trigger = "none";
            gpios = <&gpiof 12 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>; /* Pin 70 */
        };

        on5 {
            label = "on5";
            linux,default-trigger = "none";
            gpios = <&gpioi 2 (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>; /* Pin 69 */
        };
    };
    
};

&lcd_panel {
    status = "disabled";
};

&gpu {
    status = "okay";
};


&pinctrl {
    obc_rmii_pin: rmii-0 {
        pins1 {
            pinmux = <STM32_PINMUX('G', 13, AF11)>, /* ETH1_RMII_TXD0 */
                <STM32_PINMUX('G', 14, AF11)>, /* ETH1_RMII_TXD1 */
                <STM32_PINMUX('B', 11, AF11)>, /* ETH1_RMII_TX_EN */
                <STM32_PINMUX('A', 1, AF11)>,   /* ETH1_RMII_REF_CLK */
                <STM32_PINMUX('A', 2, AF11)>,  /* ETH1_MDIO */
                <STM32_PINMUX('C', 1, AF11)>;  /* ETH1_MDC */
            bias-disable;
            drive-push-pull;
            slew-rate = <2>;
        };
        pins2 {
            pinmux = <STM32_PINMUX('C', 4, AF11)>,  /* ETH1_RMII_RXD0 */
                <STM32_PINMUX('C', 5, AF11)>,  /* ETH1_RMII_RXD1 */
                <STM32_PINMUX('A', 7, AF11)>;  /* ETH1_RMII_CRS_DV */
            bias-disable;
        };
    };
    
    
    obc_rmii_sleep_pin: rmii-sleep-0 {
        pins1 {
            pinmux = <STM32_PINMUX('G', 13, ANALOG)>, /* ETH1_RMII_TXD0 */
                <STM32_PINMUX('G', 14, ANALOG)>, /* ETH1_RMII_TXD1 */
                <STM32_PINMUX('B', 11, ANALOG)>, /* ETH1_RMII_TX_EN */
                <STM32_PINMUX('A', 2, ANALOG)>,  /* ETH1_MDIO */
                <STM32_PINMUX('C', 1, ANALOG)>,  /* ETH1_MDC */
                <STM32_PINMUX('C', 4, ANALOG)>,  /* ETH1_RMII_RXD0 */
                <STM32_PINMUX('C', 5, ANALOG)>,  /* ETH1_RMII_RXD1 */
                <STM32_PINMUX('A', 1, ANALOG)>,  /* ETH1_RMII_REF_CLK */
                <STM32_PINMUX('A', 7, ANALOG)>;  /* ETH1_RMII_CRS_DV */
        };
    };
};

&ethernet0 {
    pinctrl-0 = <&obc_rmii_pin>;
    pinctrl-1 = <&obc_rmii_sleep_pin>;
    phy-mode = "rmii";
    // use own phy definition, phy0 is defined in karo layers (micrel, rgmii)
    phy-handle = <&phy1>;
};


&mdio0 {
    phy1: ethernet-phy@1 {
        // use generic phy driver (just a random ID)
        compatible = "ethernet-phy-idffff.fff0";
        
        // that is the phy ID, loads dp83848 driver, seems not compatble to the phy
        //compatible = "ethernet-phy-id2000.5c90";
        
        // results in "no phy at addr", the stmmac does not accept it
        //compatible = "ethernet-phy-ieee802.3-c22";
        reg = <1>;

        reset-assert-us = <10000>;
        reset-deassert-us = <80000>;
        reset-gpios = <&gpiog 10 (GPIO_ACTIVE_LOW | GPIO_OPEN_DRAIN)>;
    };
};
